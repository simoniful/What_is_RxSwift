# Ch.16 Testing with RxTest

ğŸ‘ğŸ»ğŸ’¯ğŸš€
â˜ğŸ» ì´ ì¥ì„ ë†“ì¹˜ì§€ ë§ˆë¼. ì—°êµ¬ ê²°ê³¼ì— ë”°ë¥´ë©´ ê°œë°œìê°€ í…ŒìŠ¤íŠ¸ ì‘ì„±ì„ ê±´ë„ˆë›°ëŠ” ì´ìœ ëŠ” ë‘ ê°€ì§€ë‹¤.

1. ë²„ê·¸ê°€ ì—†ëŠ” ì½”ë“œë¥¼ ì“´ë‹¤.
2. í…ŒìŠ¤íŠ¸ ì‘ì„±ì€ ì¬ë¯¸ì—†ë‹¤.

ì²« ë²ˆì§¸ ì´ìœ ê°€ ë‹¹ì‹ ì—ê²Œ í•´ë‹¹ëœë‹¤ë©´ ë°”ë¡œ ê³ ìš©ë  ê²ƒ! 
ë‘ ë²ˆì§¸ ì´ìœ ì— ë™ì˜í•˜ë©´ RxTestë¥¼ ë³´ì!

ì±…ì„ ì½ê¸° ì‹œì‘í•˜ê³  App í”„ë¡œì íŠ¸ì—ì„œ RxSwiftë¥¼ ì‚¬ìš©í•˜ê³  ì‹œì‘í•œ ê±° ìì²´ë¡œ, RxTestì™€ RxBlockingë¥¼ í†µí•´ RxSwift ì½”ë“œì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ë„ ì‘ì„±í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. ìì²´ë¡œ í…ŒìŠ¤íŠ¸ ì‘ì„±ì„ ì‰½ê³  ì¬ë¯¸ìˆê²Œ ë§Œë“œëŠ” ìš°ì•„í•œ APIë¥¼ ì œê³µí•œë‹¤.

ì´ë²ˆ ì±•í„°ì—ì„œëŠ” RxTest ë° RxBlockingì— ëŒ€í•´ ì•Œì•„ë³¼ ê±°ë‹¤. iOS ì•± í”„ë¡œì íŠ¸ì—ì„œ ì—¬ëŸ¬ RxSwift ì—°ì‚°ìì™€ ìƒì‚° RxSwift ì½”ë“œë¥¼ ëŒ€ìƒìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ëŠ” ì˜ˆì œë¥¼ í¬í•¨í•´ì„œ ë§ì´ë‹¤.

## Getting started

ì´ë²ˆ ì±•í„°ì˜ ì‹œì‘ í”„ë¡œì íŠ¸ ì´ë¦„ì€ Testingì´ë©°, ì…ë ¥í•œ hex ìƒ‰ìƒ ì½”ë“œì— ëŒ€í•´ì„œ ê°€ëŠ¥í•œ,  RGBê°’ê³¼ ìƒ‰ìƒ ì´ë¦„ì„ ì œê³µí•˜ëŠ” í¸ë¦¬í•œ Appì´ í¬í•¨ë˜ì–´ ìˆë‹¤. Pod ì„¤ì¹˜ë¥¼ ì‹¤í–‰í•œ í›„ í”„ë¡œì íŠ¸ workspaceì„ ì—´ê³  ì‹¤í–‰í•´ë³´ì. ì•±ì´ rayWenderrich Greenìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆì§€ë§Œ, ì„ì˜ì˜ hex ìƒ‰ìƒ ì½”ë“œë¥¼ ì…ë ¥í•˜ê³  RGBì™€ ì´ë¦„ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.

<img width="569" alt="image" src="https://user-images.githubusercontent.com/75239459/179172148-72b391e7-a67d-45f0-b7cc-2192693aba8d.png">

í•´ë‹¹ Appì€ 24 ì±•í„° "MVVM with RxSwift"ì—ì„œ ë°°ìš¸ MVVM ì„¤ê³„ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ êµ¬ì„±ëœë‹¤. ViewModelì—ëŠ” ViewControllerê°€ Viewë¥¼ ì œì–´í•˜ëŠ” ë° ì‚¬ìš©í•  ë‹¤ìŒ ë…¼ë¦¬ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©°, ì´ ë…¼ë¦¬ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ëŠ” ì±•í„°ì˜ ë’·ë¶€ë¶„ì— ì‘ì„±ëœë‹¤.

```swift
// Convert hex text to color
color = hexString
    .map { hex in
        guard hex.count == 7 else { return .clear }
        let color = UIColor(hex: hex)
        return color
    }
    .asDriver(onErrorJustReturn: .clear)

// Convert the color to an rgb tuple
rgb = color
    .map { color in
        var red: CGFloat = 0.0
        var green: CGFloat = 0.0
        var blue: CGFloat = 0.0
        color.getRed(&red, green: &green, blue: &blue, alpha: nil)
        let rgb = (Int(red * 255.0), Int(green * 255.0), Int(blue *
                                                             255.0))
        return rgb }
    .asDriver(onErrorJustReturn: (0, 0, 0))

// Convert the hex text to a matching name
colorName = hexString
    .map { hexString in
        let hex = String(hexString.dropFirst())
        if let color = ColorName(rawValue: hex) {
            return "\(color)"
        } else {
            return "--" }
    }
    .asDriver(onErrorJustReturn: "")
```

ì´ ì½”ë“œë¥¼ í…ŒìŠ¤íŠ¸í•˜ê¸° ì „ì— RxSwift Operatorì— ëŒ€í•œ ëª‡ ê°€ì§€ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ì—¬ RxTestì— ëŒ€í•´ ë°°ìš°ê²Œ ë ê±°ë‹¤.

> ì´ë²ˆ ì±•í„°ì—ì„œëŠ” XCTestë¥¼ ì‚¬ìš©í•˜ì—¬ iOSì—ì„œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ëŠ” ë° ìµìˆ™í•˜ë‹¤ê³  ìƒê°í•˜ê³  ì§„í–‰í•œë‹¤. iOSì—ì„œ ìœ ë‹› í…ŒìŠ¤íŠ¸ë¥¼ ì²˜ìŒ í•˜ëŠ” ê²½ìš° [ë¹„ë””ì˜¤ ê³¼ì •](https://videos.raywenderlich.com/cources/57-1996-ios-unit-and-ui-unit/1)ì—ì„œ iOS ìœ ë‹› ë° UI í…ŒìŠ¤íŠ¸ ì‹œì‘ì„ ì„  ìˆ˜ê°•í•˜ê¸¸ ë°”ë€ë‹¤.

## Testing operators with RxTest

RxTestëŠ” RxSwiftì™€ ë³„ë„ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤. RxSwift repo ë‚´ì—ì„œ í˜¸ìŠ¤íŒ…ë˜ì§€ë§Œ ë³„ë„ì˜ Pod ì„¤ì¹˜ ë° importê°€ í•„ìš”í•©ë‹ˆë‹¤. RxTestëŠ” RxSwift ì½”ë“œë¥¼ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•´ ë‹¤ìŒê³¼ ê°™ì€ ìœ ìš©í•œ ì¶”ê°€ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

+ Test Scheduler - ì‹œê°„ ì„ í˜• ì‘ì—… í…ŒìŠ¤íŠ¸ë¥¼ ì„¸ë¶€ì ìœ¼ë¡œ ì œì–´í•  ìˆ˜ ìˆëŠ” ê°€ìƒ ì‹œê°„ ìŠ¤ì¼€ì¤„ëŸ¬.
+ Recorded.next(_:_:), Recorded.completed(_:_:) ë° Recorded.error(_:_:) - í…ŒìŠ¤íŠ¸ì—ì„œ ì§€ì •ëœ ì‹œê°„ì— ì´ëŸ¬í•œ ì´ë²¤íŠ¸ë¥¼ ê´€ì°° ê°€ëŠ¥í•œ ê³µì¥ ë©”ì„œë“œ.

RxTestëŠ” Hot ë° Cold Observable ë§Œë“¤ì–´ë‚´ì–´ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤. 

## What are hot and cold observables?

RxSwiftëŠ” Rx ì½”ë“œë¥¼ ê°„ì†Œí™”í•˜ê³  ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•´ ë§ì€ ë…¸ë ¥ì„ ê¸°ìš¸ì¸ë‹¤. RxSwift ì»¤ë®¤ë‹ˆí‹°ì—ëŠ” Hot ë° Cold Observableì„ êµ¬ì²´ì ì¸ type ëŒ€ì‹  Observableì˜ íŠ¹ì„±ìœ¼ë¡œ ìƒê°í•´ì•¼ í•œë‹¤ëŠ” ì˜ê²¬ì´ ìˆë‹¤.
ì´ê²ƒì€ êµ¬í˜„ ì„¸ë¶€ ì‚¬í•­ì´ì§€ë§Œ, í…ŒìŠ¤íŠ¸ë¥¼ ì œì™¸í•˜ê³  RxSwiftì—ì„œ Hot ë° Cold Observableì— ëŒ€í•œ ë§ì€ ì´ì•¼ê¸°ë“¤ì„ ë³¼ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ì£¼ì˜í•  í•„ìš”ê°€ ìˆë‹¤.

+ Hot Observable:
  + êµ¬ë…ìê°€ ìˆëŠ”ì§€ ì—¬ë¶€ì— ê´€ê³„ì—†ì´ ë¦¬ì†ŒìŠ¤ë¥¼ ì‚¬ìš©.
  + êµ¬ë…ìê°€ ìˆëŠ”ì§€ ì—¬ë¶€ì— ê´€ê³„ì—†ì´ ìš”ì†Œë¥¼ ìƒì„±.
  + ì£¼ë¡œ Behavior Relayì™€ ê°™ì€ ìƒíƒœ ì €ì¥ ìœ í˜•ê³¼ í•¨ê»˜ ì‚¬ìš©.
+ Cold Observable:
  + êµ¬ë… ì‹œì—ë§Œ ë¦¬ì†ŒìŠ¤ë¥¼ ì‚¬ìš©.
  + êµ¬ë…ìê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ ìš”ì†Œë¥¼ ìƒì„±.
  + ë„¤íŠ¸ì›Œí‚¹ê³¼ ê°™ì€ ë¹„ë™ê¸° ì‘ì—…ì— ì£¼ë¡œ ì‚¬ìš©.

ê³§ ì‘ì„±í•  ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” Hot Observableë¥¼ ì‚¬ìš©í•˜ê² ì§€ë§Œ, ì´ëŸ¬í•œ ì°¨ì´ë¥¼ ì•Œê³  ìˆëŠ” ê²½ìš° Cold Observableì„ ì‚¬ìš©í•´ì•¼ í•  ìˆ˜ë„ ìˆë‹¤.

```swift
class TestingOperators : XCTestCase {
  var scheduler: TestScheduler!
  var subscription: Disposable!

  override func setUp() {
    super.setUp()
    // í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ê°€ ì‹œì‘ë˜ê¸° ì „ì— í˜¸ì¶œë˜ëŠ” setUp() ë©”ì„œë“œì—ì„œ ì´ˆê¸° í´ëŸ­ ê°’ 0ìœ¼ë¡œ ìƒˆ ìŠ¤ì¼€ì¤„ëŸ¬ë¥¼ ì´ˆê¸°í™”
    scheduler = TestScheduler(initialClock: 0)
  }

  override func tearDown() {
    // í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ê°€ ì¢…ë£Œë˜ê³  í…ŒìŠ¤íŠ¸ êµ¬ë…ì„ 1000ì´ˆì˜ ê°€ìƒ ì‹œê°„ ë‹¨ìœ„ë¡œ íê¸°í•˜ë„ë¡ ì˜ˆì•½í•˜ê³  ìŠ¤ì¼€ì¤„ëŸ¬ë¥¼ nilìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ë©”ëª¨ë¦¬ë¥¼ í•´ì œ
    scheduler.scheduleAt(1000) {
      self.subscription.dispose()
    }
    scheduler = nil
    super.tearDown()
  }

  // amb(_:)ëŠ”Â amb(_:)ë¡œ ì—®ì¸ ì—¬ëŸ¬ ì‹œí€€ìŠ¤ ì¤‘ì—ì„œ ê°€ì¥ ë¨¼ì € ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¨ ì‹œí€€ìŠ¤ì˜ ì´ë²¤íŠ¸ë§Œ ì „ë‹¬
  func test_Amb() {
    let observer = scheduler.createObserver(String.self)
    let observableA = scheduler.createHotObservable([
      .next(100, "a"),
      .next(200, "b"),
      .next(300, "c")
    ])

    let observableB = scheduler.createHotObservable([
      .next(90, "1"),
      .next(200, "2"),
      .next(300, "3")
    ])

    let ambObservable = observableA.amb(observableB)
    self.subscription = ambObservable.subscribe(observer)
    scheduler.start()

    let results = observer.events.compactMap {
      $0.value.element
    }

    XCTAssertEqual(results, ["1", "2", "3"])
  }

  // filter(_:)ëŠ” ì‹œí€€ìŠ¤ ì¤‘ì—ì„œ ì¡°ê±´ì— ì¼ì¹˜í•˜ëŠ” ì´ë²¤íŠ¸ë§Œ ì „ë‹¬
  func test_Filter() {
    let observer = scheduler.createObserver(Int.self)
    let observable = scheduler.createHotObservable([
      .next(100, 1),
      .next(200, 2),
      .next(300, 3),
      .next(400, 2),
      .next(500, 1)
    ])

    let filterObservable = observable.filter {
      $0 < 3
    }

    scheduler.scheduleAt(0) {
      self.subscription = filterObservable.subscribe(observer)
    }

    scheduler.start()

    let results = observer.events.compactMap {
      $0.value.element
    }

    XCTAssertEqual(results, [1, 2, 2, 1])
  }
}
```

## Using RxBlocking

RxBlockingì€ ìì²´ podê°€ ìˆëŠ” RxSwift repoì— í¬í•¨ëœ ë˜ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì´ë©° ë³„ë„ë¡œ import í•´ì•¼í•œë‹¤. 

ì£¼ìš” ëª©ì ì€ observableì„ BlockingObservableë¡œ  toBlocking(timeout:) ë©”ì„œë“œë¥¼ í†µí•´ì„œ ë³€í™˜í•˜ëŠ” ê²ƒ! ì´ë ‡ê²Œ í•˜ë©´ ì •ìƒì ìœ¼ë¡œ ë˜ëŠ” ì‹œê°„ ì´ˆê³¼ì— ë„ë‹¬í•˜ì—¬ ê´€ì°° ê°€ëŠ¥í•œ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•œë‹¤. 

timeoutì— ì „ë‹¬í•˜ëŠ” ì¸ìëŠ” optional TimeInterval íƒ€ì…ìœ¼ë¡œ ê¸°ë³¸ê°’ì€ nilì´ë‹¤. ë§Œì•½ timeout ê°’ì„ ì„¤ì •í•˜ê³  observableì´ ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ê¸° ì „ì— í•´ë‹¹ intervalì´ ê²½ê³¼í•˜ë©´, toBlocking ë©”ì„œë“œì—ì„œëŠ” RxError.timeout ì˜¤ë¥˜ë¥¼ ë˜ì§€ê²Œ ëœë‹¤. ì´ëŠ” ë³¸ì§ˆì ìœ¼ë¡œ ë¹„ë™ê¸°ì‹ ì‘ì—…ì„ ë™ê¸°ì‹ ì‘ì—…ìœ¼ë¡œ ë³€í™˜í•˜ë¯€ë¡œ í…ŒìŠ¤íŠ¸ê°€ í›¨ì”¬ ì‰¬ì›Œì§€ê²Œ ëœë‹¤.

ì•„ë˜ ì²« ë²ˆì§¸ ì˜ˆì œì—ì„œ toBlocking() ì—°ì‚°ìëŠ” ArrayObservableë¡œ ë³€í™˜í•˜ì—¬ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ìƒì„±í•œ ìŠ¤ë ˆë“œë¥¼ ì¢…ë£Œí•  ë•Œê¹Œì§€ ì°¨ë‹¨í•œë‹¤. í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ë©´ ë¹„ë™ê¸°ì‹ ì‘ì—…ì„ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•œ ì„¸ ì¤„ì˜ ì½”ë“œ ì„±ê³µ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤. 

```swift
public enum MaterializedSequenceResult<T> {
  case completed(elements: [T])
  case failed(elements: [T], error: Error)
}
```

RxBlockingì—ëŠ” ì°¨ë‹¨ ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ì¡°ì‚¬í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” .materialize() operatorë„ ìˆë‹¤.  completed / failed ë‘ ê°œì˜ ì¼€ì´ìŠ¤ì™€ ê´€ë ¨ ê°’ì„ í¬í•¨í•˜ëŠ” ì—´ê±°í˜• íƒ€ì…ì¸ MaterializedSequenceResult(MaterializedSequenceResult)ê°€ ë°˜í™˜ëœë‹¤.

observableì´ ì„±ê³µì ìœ¼ë¡œ ì¢…ë£Œë˜ë©´, completed ì¼€ì´ìŠ¤ì˜ ê²½ìš° ê¸°ë³¸ observableë“¤ë¡œë¶€í„° ë°©ì¶œëœ ìš”ì†Œë“¤ì˜ ë°°ì—´ê³¼ ê´€ë ¨ë  ê²ƒì´ë‹¤. ê·¸ë¦¬ê³  ì‹¤íŒ¨í•˜ë©´, failed ì¼€ì´ìŠ¤ëŠ” ìš”ì†Œ ë°°ì—´ê³¼ ì˜¤ë¥˜ë¥¼ ëª¨ë‘ ê´€ë ¨ ë˜ì–´ ë‚˜ì˜¤ê²Œ ëœë‹¤. ì•„ë˜ ë‘ ë²ˆì§¸ ì˜ˆì œë¥¼ ë³´ì. ì˜ˆì œëŠ”  materializeë¥¼ ì‚¬ìš©í•˜ì—¬ toArray ëŒ€í•œ ì´ì „ í…ŒìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ êµ¬í˜„í•œë‹¤.

```swift
  func test_ToArray() throws {
    // ê¸°ë³¸ qosë¡œ ë¹„ë™ê¸° í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•  ë™ì‹œ ìŠ¤ì¼€ì¤„ëŸ¬ë¥¼ ìƒì„±.
    let scheduler = ConcurrentDispatchQueueScheduler(qos: .default)

    // ìŠ¤ì¼€ì¤„ëŸ¬ì—ì„œ ë‘ ì •ìˆ˜ì˜ observable êµ¬ë…í•œ ê²°ê³¼ë¥¼ ë³´ìœ í•  observableì„ ë§Œë“ ë‹¤.
    let toArrayObservable = Observable.of(1, 2).subscribeOn(scheduler)

    // ArrayObservableì— ëŒ€í•´ Blocking()ì„ í˜¸ì¶œí•œ ê²°ê³¼ì— ëŒ€í•´ toArrayë¥¼ ì‚¬ìš©í•˜ê³ , Arrayë¡œ ë°˜í™˜ë˜ëŠ” ê°’ì„ ì˜ˆìƒëœ ê²°ê³¼ì™€ expect í•œë‹¤.
    XCTAssertEqual(try toArrayObservable.toBlocking().toArray(), [1, 2])
  }

  func test_ToArrayMaterialized() {
    // ìœ„ì™€ ë™ì¼
    let scheduler = ConcurrentDispatchQueueScheduler(qos: .default)
    let toArrayObservable = Observable.of(1, 2).subscribeOn(scheduler)

    // toBlocking()ê³¼ materialize()ë¥¼ observableì— í˜¸ì¶œí•˜ê³  ê²°ê³¼ë¥¼ í• ë‹¹
    let result = toArrayObservable
      .toBlocking()
      .materialize()

    // ì˜ˆìƒëœ ê²°ê³¼ì— ë”°ë¼ ì¼€ì´ìŠ¤ ë¶„ë¦¬ë¥¼ í†µí•œ expect ë¶„ê¸° ë¹„êµ
    switch result {
    case .completed(let elements):
      XCTAssertEqual(elements,  [1, 2])
    case .failed(_, let error):
      XCTFail(error.localizedDescription)
    }
  }
```

í…ŒìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ê³  ëª¨ë“  í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µí–ˆëŠ”ì§€ í™•ì¸í•´ë³´ì. ë³´ë‹¤ì‹œí”¼ RxBlockingì˜ materialize() ì‚¬ìš©ë²•ì€ RxSwiftì™€ ë‹¤ë¥´ì§€ë§Œ ê°œë…ì ìœ¼ë¡œëŠ” ìœ ì‚¬í•˜ë‹¤. RxBlocking ë²„ì „ì€ ê²°ê³¼ë¥¼ ë³´ë‹¤ ê°•ë ¥í•˜ê³  ëª…ì‹œì ìœ¼ë¡œ ì¡°ì‚¬í•˜ê¸° ìœ„í•´ ê²°ê³¼ë¥¼ ì—´ê±°í˜•ìœ¼ë¡œ ëª¨ë¸ë§í•˜ëŠ” ì¶”ê°€ ë‹¨ê³„ë¥¼ ê±°ì¹œë‹¤.
ê³§ RxBlockingìœ¼ë¡œ ë” ë§ì€ ì‘ì—…ì„ í•˜ê²Œ ë˜ê² ì§€ë§Œ, ì´ì œëŠ” operator í…ŒìŠ¤íŠ¸ì—ì„œ ë²—ì–´ë‚˜ ì•±ì˜ í”„ë¡œë•ì…˜ ì½”ë“œì— ëŒ€í•œ ëª‡ ê°€ì§€ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•´ë³´ì.

## Testing RxSwift production code

```swift
import XCTest
import RxSwift
import RxCocoa
import RxTest
@testable import Testing

class TestingViewModel : XCTestCase {
  var viewModel: ViewModel!
  var scheduler: ConcurrentDispatchQueueScheduler!

  override func setUp() {
    super.setUp()

    viewModel = ViewModel()
    scheduler = ConcurrentDispatchQueueScheduler(qos: .default)
  }

  func test_ColorIsRedWhenHexStringIsFF0000_async() {
    let disposeBag = DisposeBag()

    // ë‚˜ì¤‘ì— ë‹¬ì„±í•  expectation ìƒì„±
    let expect = expectation(description: #function)

    // ì˜ˆìƒë˜ëŠ” í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ìƒì„±. ì˜ˆìƒ ìƒ‰ìƒì€ ë¹¨ê°•
    let expectedColor = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0)

    // ë‚˜ì¤‘ì— í• ë‹¹í•  ê²°ê³¼ë¥¼ ì„ ì–¸
    var result: UIColor!

    // ë·° ëª¨ë¸ì˜ ì»¬ëŸ¬ì— ëŒ€í•œ êµ¬ë…ì„ ë§Œë“¬. êµ¬ë… ì‹œ ë“œë¼ì´ë²„ê°€ ì´ˆê¸° ìš”ì†Œë¥¼ ì¬ìƒí•˜ê¸° ë•Œë¬¸ì— ì²« ë²ˆì§¸ ìš”ì†ŒëŠ” ê±´ë„ˆëœ€.
    viewModel.color.asObservable()
      .skip(1)
      .subscribe(onNext: {
        // ë‹¤ìŒ ì´ë²¤íŠ¸ ìš”ì†Œë¥¼ ê²°ê³¼ì— í• ë‹¹í•˜ê³  expectì˜ fulfill()ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.
        result = $0
        expect.fulfill()
      })
      .disposed(by: disposeBag)

    // ë·° ëª¨ë¸ì˜ hexStringì— "#ff0000" ë¬¸ìì—´ ì£¼ì…
    viewModel.hexString.accept("#ff0000")

    // 1ì´ˆê°„ì˜ íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ê¸°ëŒ€ì— ë¶€ì‘í•  ë•Œê¹Œì§€ ëŒ€ê¸°. í´ë¡œì €ì—ì„œ errorë¥¼ guard
    waitForExpectations(timeout: 1.0) { error in
      guard error == nil else {
        XCTFail(error!.localizedDescription)
        return
      }

      // ë‹¤ìŒ ì˜ˆìƒ ìƒ‰ìƒì´ ì‹¤ì œ ê²°ê³¼ì™€ ê°™ë‹¤ê³  expect ë¹„êµ
      XCTAssertEqual(expectedColor, result)
    }
  }

  func test_ColorIsRedWhenHexStringIsFF0000() throws {
    // colorObservableì„ ë§Œë“¤ì–´ ë™ì‹œ ìŠ¤ì¼€ì¤„ëŸ¬ì—ì„œ êµ¬ë…í•œ ê²°ê³¼ë¥¼ ìœ ì§€
    let colorObservable = viewModel.color.asObservable().subscribeOn(scheduler)

    // ë·° ëª¨ë¸ì˜ hexStringì— "#ff0000" ë¬¸ìì—´ ì£¼ì…
    viewModel.hexString.accept("#ff0000")

    // colorObservableë¥¼ toBlocking()í•˜ê³  ì²« ë²ˆì§¸ ìš”ì†Œê°€ ë°©ì¶œë  ë•Œê¹Œì§€ ëŒ€ê¸°. ì˜ˆìƒ ìƒ‰ìƒì„ ê²°ê³¼ì™€ ê°™ë‹¤ê³  expect ë¹„êµ
    XCTAssertEqual(try colorObservable.toBlocking(timeout: 1.0).first(),
                   .red)
  }

  func test_RgbIs010WhenHexStringIs00FF00() throws {
    // ìŠ¤ì¼€ì¤„ëŸ¬ì—ì„œ êµ¬ë…í•  rgbObservableì„ ìƒì„±
    let rgbObservable = viewModel.rgb.asObservable().subscribeOn(scheduler)

    // ë·° ëª¨ë¸ì˜ hexStringì— "#00ff00" ë¬¸ìì—´ ì£¼ì…
    viewModel.hexString.accept("#00ff00")

    // blocking ëœ rgbOservableë¡œ í˜¸ì¶œí•œ ì²« ë²ˆì§¸ ê²°ê³¼ë¥¼ ê²€ìƒ‰í•œ ë‹¤ìŒ ê° ê°’ì´ ê²°ê³¼ì™€ ê°™ë‹¤ê³  expect ë¹„êµ
    let result = try rgbObservable.toBlocking().first()!

    // 0ì—ì„œ 1ë¡œ, 0ì—ì„œ 255ë¡œ ë³€í™˜í•œ ê²ƒì€ ë‹¨ì§€ í…ŒìŠ¤íŠ¸ ì´ë¦„ê³¼ ì¼ì¹˜í•˜ê³  ë”°ë¼ í•˜ê¸° ì‰½ê²Œ í•˜ê¸° ìœ„í•´
    XCTAssertEqual(0 * 255, result.0)
    XCTAssertEqual(1 * 255, result.1)
    XCTAssertEqual(0 * 255, result.2)
  }

  func testColorNameIsRayWenderlichGreenWhenHexStringIs006636() throws {
    // ìŠ¤ì¼€ì¤„ëŸ¬ì—ì„œ êµ¬ë…í•  colorNameObservableì„ ìƒì„±
    let colorNameObservable = viewModel.colorName.asObservable().subscribeOn(scheduler)

    // ë·° ëª¨ë¸ì˜ hexStringì— "#006636" ë¬¸ìì—´ ì£¼ì…
    viewModel.hexString.accept("#006636")

    // ë‹¤ìŒ ê° ê°’ì´ ê²°ê³¼ì™€ ê°™ë‹¤ê³  expect ë¹„êµ
    XCTAssertEqual("rayWenderlichGreen", try colorNameObservable.toBlocking().first()!)
  }
}
```

"í—¹êµ¬ê³  ë°˜ë³µí•˜ë¼"ëŠ” ë§ì´ ë– ì˜¤ë¥´ì§€ë§Œ ì¢‹ì€ ì˜ë¯¸ë¡œ ì½íŒë‹¤. í…ŒìŠ¤íŠ¸ëŠ” í•­ìƒ ì´ë ‡ê²Œ ì‰¬ì›Œì•¼ í•œë‹¤. 
Command-Uë¥¼ ëˆŒëŸ¬ ì´ í”„ë¡œì íŠ¸ì˜ ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ë©´ ëª¨ë“  ê²ƒì´ ì˜ ì „ë‹¬ëœë‹¤

## Where to go from here?

RxText ë° RxBlockingì„ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì€ RxSwift ë° RxCocoaë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ë° UI ë°”ì¸ë”© ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒê³¼ ìœ ì‚¬í•˜ë‹¤. 24 ì±•í„° "MVVM with RxSwift"ì—ì„œ ë” ë§ì€ ë·° ëª¨ë¸ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•  ì˜ˆì •ì´ë©° ê·¸ ë•Œ ê°€ì„œ ë‹¤ì‹œ ë§Œë‚˜ë³´ì












